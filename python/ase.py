import ipfn
import iteround
import numpy as np
import pandas as pd
import sqlalchemy as sql

import python.utils as utils


def _get_controls_inputs(year: int) -> dict[str, pd.DataFrame]:
    """Get inputs required to calculate regional age/sex/ethnicity controls."""
    with utils.ESTIMATES_ENGINE.connect() as conn:
        # Get regional age/sex/ethnicity controls for total population
        with open(utils.SQL_FOLDER / "ase/get_region_ase_total.sql") as file:
            region_ase_total = pd.read_sql_query(
                sql=sql.text(file.read()),
                con=conn,
                params={
                    "run_id": utils.RUN_ID,
                    "year": year,
                },
            )

        # Get regional age/sex/ethnicity group quarters distributions
        with open(utils.SQL_FOLDER / "ase/get_region_gq_ase_dist.sql") as file:
            region_gq_ase_dist = pd.read_sql_query(
                sql=sql.text(file.read()),
                con=conn,
                params={
                    "run_id": utils.RUN_ID,
                    "year": year,
                },
            )

        # Get regional population by type output generated by Estimates program
        with open(utils.SQL_FOLDER / "ase/get_region_pop_type.sql") as file:
            region_pop_type = pd.read_sql_query(
                sql=sql.text(file.read()),
                con=conn,
                params={
                    "run_id": utils.RUN_ID,
                    "year": year,
                },
            )

    return {
        "region_ase_total": region_ase_total,
        "region_gq_ase_dist": region_gq_ase_dist,
        "region_pop_type": region_pop_type,
    }


def _create_controls(controls_inputs: dict[str, pd.DataFrame]) -> pd.DataFrame:
    """Create regional age/sex/ethnicity controls by population type."""

    # Load input data into separate variables for cleaner manipulation
    region_ase_total = controls_inputs["region_ase_total"]
    region_gq_ase_dist = controls_inputs["region_gq_ase_dist"]
    region_pop_type = controls_inputs["region_pop_type"]

    # Scale the regional age/sex/ethnicity total controls to the regional population
    region_ase_total["population"] = iteround.saferound(
        region_ase_total["population"].astype(float),
        places=0,
        topline=region_pop_type["value"].sum(),
    )

    # Calculate the group quarters age/sex/ethnicity population
    # Pivot the group quarters age/sex/ethnicity population by type
    # Such that age/sex/ethnicity categories are rows
    # And group quarters population by type are columns
    gq_pop = (
        region_gq_ase_dist.merge(
            right=region_pop_type, left_on="gq_type", right_on="pop_type"
        )
        .assign(value=lambda x: x["value"] * x["distribution"])
        .sort_values(by=["pop_type"])
        .pivot(
            index=["age_group", "sex", "ethnicity"],
            columns="pop_type",
            values="value",
        )
        .sort_index()
    )

    # Create row marginal controls for age/sex/ethnicity categories
    row_crtls = region_ase_total.sort_values(by=["age_group", "sex", "ethnicity"])[
        "population"
    ].to_list()

    # Create column marginal controls for group quarters population by type
    col_crtls = (
        region_pop_type[region_pop_type["pop_type"] != "Household Population"]
        .sort_values(by=["pop_type"])["value"]
        .to_list()
    )

    # Integerize the group quarters age/sex/ethnicity population by type
    region_gq_ase = utils.integerize_2d(
        df=gq_pop,
        row_crtls=row_crtls,
        col_crtls=col_crtls,
        condition="less than",
    )

    # Calculate the household age/sex/ethnicity population as the remainder
    # Return the regional age/sex/ethnicity controls by population type
    return (
        region_ase_total.merge(
            right=region_gq_ase.assign(gq=lambda x: x.sum(axis=1)).reset_index(),
            on=["age_group", "sex", "ethnicity"],
        )
        .assign(hhp=lambda x: x["population"] - x["gq"])
        .drop(columns=["population", "gq"])
        .rename(columns={"hhp": "Household Population"})
        .melt(
            id_vars=["run_id", "year", "age_group", "sex", "ethnicity"],
            var_name="pop_type",
        )
    )


def _insert_controls(outputs: pd.DataFrame) -> None:
    """Insert regional age/sex/ethnicity controls to database."""
    with utils.ESTIMATES_ENGINE.connect() as conn:
        outputs.to_sql(
            name="controls_ase",
            con=conn,
            schema="inputs",
            if_exists="append",
            index=False,
        )


def _get_seed_inputs(year: int) -> dict[str, pd.DataFrame]:
    """Get inputs required to generate census tract age/sex/ethnicity seed data."""
    with utils.ESTIMATES_ENGINE.connect() as conn:
        # Get the Age/Sex B010001 table data
        with open(utils.SQL_FOLDER / "ase/get_B01001.sql") as file:
            b01001 = pd.read_sql_query(
                sql=sql.text(file.read()),
                con=conn,
                params={
                    "year": year,
                },
            )

        # Get the Ethnicity B03002 table data
        with open(utils.SQL_FOLDER / "ase/get_B03002.sql") as file:
            b03002 = pd.read_sql_query(
                sql=sql.text(file.read()),
                con=conn,
                params={
                    "year": year,
                },
            )

        # Get Age/Sex/Ethnicity data from B01001(B-I) table data
        with open(utils.SQL_FOLDER / "ase/get_B01001(B-I).sql") as file:
            b01001_b_i = pd.read_sql_query(
                sql=sql.text(file.read()),
                con=conn,
                params={
                    "year": year,
                },
            )

    return {"b01001": b01001, "b03002": b03002, "b01001_b_i": b01001_b_i}


def _create_seed(seed_inputs: dict[str, pd.DataFrame]) -> pd.DataFrame:
    """Create census tract age/sex/ethnicity seed data."""
    # Create dictionary of DataFrames and their dimensions to be used in IPF
    dimensions = {
        "b01001": {"labels": ["age_group", "sex"], "values": [0, 1]},
        "b03002": {"labels": ["ethnicity"], "values": [2]},
        "b01001_b_i": {
            "labels": ["age_group", "sex", "ethnicity"],
            "values": [0, 1, 2],
        },
    }

    output = []
    # Within each census tract
    for tract in seed_inputs["b01001_b_i"]["tract"].unique():
        # Create inputs to IPF of numpy ndarrays
        ipf_inputs = {}
        for table, metadata in dimensions.items():
            frame = (
                seed_inputs[table][seed_inputs[table]["tract"] == tract]
                .groupby(metadata["labels"])["value"]
                .sum()
            )

            if len(metadata["labels"]) == 1:
                ipf_inputs[table] = frame.to_numpy()
            else:
                ipf_inputs[table] = np.reshape(
                    frame.to_numpy(), tuple(map(len, frame.index.levels))
                )

        # Run IPF
        ipf = ipfn.ipfn.ipfn(
            ipf_inputs["b01001_b_i"],
            aggregates=[ipf_inputs["b01001"], ipf_inputs["b03002"]],
            dimensions=[
                dimensions["b01001"]["values"],
                dimensions["b03002"]["values"],
            ],
            max_iteration=10000,
        )

        # Transform result back to DataFrame
        result = (
            seed_inputs["b01001_b_i"][dimensions["b01001_b_i"]["labels"]]
            .drop_duplicates()
            .sort_values(by=dimensions["b01001_b_i"]["labels"])
            .assign(tract=tract, value=ipf.iteration().flatten())
        )

        # Append to output list
        output.append(result)

    return pd.concat(output, ignore_index=True)
