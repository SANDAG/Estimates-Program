# Container for the Household Characteristics module. See the Estimates-Program wiki
# page for more details:
# https://github.com/SANDAG/Estimates-Program/wiki/Household-Characteristics

import numpy as np
import pandas as pd
import sqlalchemy as sql

import python.utils as utils
import python.tests as tests


def run_hh_characteristics(year: int) -> None:
    """Orchestrator function to calculate and insert household characteristics.

    The exact household characteristics created are:
    1. Households split by household income category
    2. Households split by number of people in each household

    Both characteristics are generated by applying ACS data to MGRA level households,
    which are created by the HS/HH module.

    Functionality is segmented into functions for code encapsulation:
        _get_hh_char_inputs - Get MGRA households (which are used for both
            characteristics) and ACS tract rates
        _validate_hh_char_inputs - Validate the hh characteristics input data
        _create_hh_char - Calculate the hh characteristics listed above
        _validate_hh_char_outputs - Validate the hh characteristics output data
        _insert_hh_char - Insert hh characteristics and tract level controls to database

    Args:
        year (int): estimates year
    """
    hh_char_inputs = _get_hh_char_inputs(year)
    _validate_hh_char_inputs(year, hh_char_inputs)

    hh_char_outputs = _create_hh_char(hh_char_inputs)
    _validate_hh_char_outputs(hh_char_outputs)

    _insert_hh_char(hh_char_inputs, hh_char_outputs)


def _get_hh_char_inputs(year: int) -> dict[str, pd.DataFrame]:
    """Get households and various tract level datas"""
    with utils.ESTIMATES_ENGINE.connect() as con:
        # Store results here
        hh_char_inputs = {}

        # Get MGRA level households. Note we re-use the SQL script from the 'Population
        # by Type' module
        with open(utils.SQL_FOLDER / "pop_type" / "get_mgra_hh.sql") as file:
            hh_char_inputs["hh"] = pd.read_sql_query(
                sql=sql.text(file.read()),
                con=con,
                params={
                    "run_id": utils.RUN_ID,
                    "year": year,
                    "mgra_version": utils.MGRA_VERSION,
                },
            ).drop(columns=["city"])

        # Tract level household income distributions
        with open(
            utils.SQL_FOLDER / "hh_characteristics" / "get_tract_controls_hh_income.sql"
        ) as file:
            hh_char_inputs["hh_income_tract_controls"] = utils.read_sql_query_acs(
                sql=sql.text(file.read()),
                con=con,
                params={"run_id": utils.RUN_ID, "year": year},
            )

        # Tract level households by household size distributions
        with open(
            utils.SQL_FOLDER
            / "hh_characteristics"
            / "get_tract_controls_hh_by_size.sql"
        ) as file:
            hh_char_inputs["hhs_tract_controls"] = utils.read_sql_query_acs(
                sql=sql.text(file.read()),
                con=con,
                params={"run_id": utils.RUN_ID, "year": year},
            )

        # MGRA level household size controls
        with open(
            utils.SQL_FOLDER / "hh_characteristics" / "get_mgra_controls_hh_by_size.sql"
        ) as file:
            hh_char_inputs["hhs_mgra_controls"] = pd.read_sql_query(
                sql=sql.text(file.read()),
                con=con,
                params={"run_id": utils.RUN_ID, "year": year},
            )

    return hh_char_inputs


def _validate_hh_char_inputs(
    year: int, hh_char_inputs: dict[str, pd.DataFrame]
) -> None:
    """Validate the household characteristics input data"""
    tests.validate_data(
        "MGRA households",
        hh_char_inputs["hh"],
        row_count={"key_columns": {"mgra"}},
        negative={},
        null={},
    )
    tests.validate_data(
        "Tract household income distribution",
        hh_char_inputs["hh_income_tract_controls"],
        row_count={"key_columns": {"tract", "income_category"}, "year": year},
        negative={},
        null={},
    )
    tests.validate_data(
        "Tract households by household size distribution",
        hh_char_inputs["hhs_tract_controls"],
        row_count={"key_columns": {"tract", "household_size"}, "year": year},
        negative={},
        null={},
    )
    tests.validate_data(
        "MGRA households by household size controls",
        hh_char_inputs["hhs_mgra_controls"],
        row_count={"key_columns": {"mgra"}},
        negative={},
        null={},
    )


def _create_hh_char(hh_char_inputs: dict[str, pd.DataFrame]) -> dict[str, pd.DataFrame]:
    """Calculate the various household characteristics by MGRA."""
    return {
        "hh_income": _create_hh_income(
            hh_char_inputs["hh"], hh_char_inputs["hh_income_tract_controls"]
        ),
        "hh_size": _create_hh_size(
            hh_char_inputs["hh"],
            hh_char_inputs["hhs_tract_controls"],
            hh_char_inputs["hhs_mgra_controls"],
        ),
    }


def _create_hh_income(
    hh: pd.DataFrame, tract_income_dist: pd.DataFrame
) -> pd.DataFrame:
    """Code to compute MGRA household income"""
    # Combine the total households in each MGRA with the distribution of households by
    # income
    hh_income = (
        hh.merge(tract_income_dist, on=["run_id", "year", "tract"], how="left")
        .assign(hh=lambda df: df["hh"] * df["value"])
        .drop(columns=["tract", "value"])
    )

    # Control each MGRA so households by household income exactly matches the total
    # households
    integerized_groups = []
    for _, group in hh_income.groupby("mgra"):
        group["hh"] = utils.integerize_1d(group["hh"])
        integerized_groups.append(group)
    hh_income = pd.concat(integerized_groups)

    return hh_income


def _create_hh_size(
    hh: pd.DataFrame, tract_hhs_dist: pd.DataFrame, mgra_controls: pd.DataFrame
) -> pd.DataFrame:
    """Code to compute MGRA households by size"""
    # Combine the total households in each MGRA with the distribution of households by
    # income
    hh_size = (
        hh.merge(tract_hhs_dist, on=["run_id", "year", "tract"], how="left")
        .assign(hh=lambda df: df["hh"] * df["value"])
        .drop(columns=["tract", "value"])
    )

    # Control each MGRA so households by household income exactly matches the total
    # households
    integerized_groups = []
    for _, group in hh_size.groupby("mgra"):
        group["hh"] = utils.integerize_1d(group["hh"])
        integerized_groups.append(group)
    hh_size = pd.concat(integerized_groups)

    # Control each MGRA to align with household population
    controlled_groups = []
    for mgra, group in hh_size.groupby("mgra"):
        control = mgra_controls[mgra_controls["mgra"] == mgra]
        hhp_total = control["hhp_total"].values[0]
        hhp_over_18 = control["hhp_over_18"].values[0]

        # Compute the minimum and maximum implied hhp from the hhs distribution. The
        # maximum assumes every 7+ hh actually has 11 people on average
        min_implied_hhp = (group["hh"] * group["household_size"]).sum()
        max_implied_hhp = (group["hh"] * group["household_size"].replace(7, 11)).sum()

        # If the maximum implied hhp is smaller than the actual hhp, then we need to
        # shift some households from smaller sizes to larger sizes. Specifically, we
        # will shift one household from 1-->2, 2-->3, 6-->7+, 1-->2, etc. until
        # satisfied
        if max_implied_hhp < hhp_total:
            size_to_change = 1
            while max_implied_hhp < hhp_total:
                if group[group["household_size"] == size_to_change]["hh"].values[0] > 0:
                    group.loc[group["household_size"] == size_to_change, "hh"] -= 1
                    group.loc[group["household_size"] == size_to_change + 1, "hh"] += 1
                    max_implied_hhp += 1
                # Increase the size by one, but keep it in the inclusive range 1-6
                size_to_change = (size_to_change % 6) + 1

        # If the minimum implied hhp is greater than the actual hhp, then we need to
        # shift some households from larger sizes to smaller sizes
        if min_implied_hhp > hhp_total:
            size_to_change = 7
            while min_implied_hhp > hhp_total:
                if group[group["household_size"] == size_to_change]["hh"].values[0] > 0:
                    group.loc[group["household_size"] == size_to_change, "hh"] -= 1
                    group.loc[group["household_size"] == size_to_change - 1, "hh"] += 1
                    min_implied_hhp -= 1
                # Decrease size by one, but keep it in the inclusive range 2-7
                size_to_change = (size_to_change - 3) % 6 + 2

        # TODO: Check hhs1 against over 18 hhp

        # Store the controlled group
        controlled_groups.append(group)

    return pd.concat(controlled_groups)


def _validate_hh_char_outputs(hh_char_outputs: dict[str, pd.DataFrame]) -> None:
    """Validate the household characteristics data"""
    tests.validate_data(
        "MGRA Household Income",
        hh_char_outputs["hh_income"],
        row_count={"key_columns": {"mgra", "income_category"}},
        negative={},
        null={},
    )
    tests.validate_data(
        "MGRA Households by Size",
        hh_char_outputs["hh_size"],
        row_count={"key_columns": {"mgra", "household_size"}},
        negative={},
        null={},
    )


def _insert_hh_char(
    hh_char_inputs: dict[str, pd.DataFrame], hh_char_outputs: dict[str, pd.DataFrame]
) -> None:
    """Insert hh characteristics and tract level controls to database"""
    with utils.ESTIMATES_ENGINE.connect() as con:
        hh_char_inputs["hh_income_tract_controls"][
            ["run_id", "year", "tract", "income_category", "value"]
        ].rename(columns={"income_category": "metric"}).assign(
            metric=lambda df: "Income Category - " + df["metric"]
        ).to_sql(
            schema="inputs",
            name="controls_tract",
            if_exists="append",
            con=con,
            index=False,
        )

        hh_char_outputs["hh_income"][
            ["run_id", "year", "mgra", "income_category", "hh"]
        ].rename(columns={"income_category": "metric", "hh": "value"}).assign(
            metric=lambda df: "Income Category - " + df["metric"]
        ).to_sql(
            schema="outputs",
            name="hh_characteristics",
            if_exists="append",
            con=con,
            index=False,
        )

        hh_char_outputs["hh_size"][
            ["run_id", "year", "mgra", "household_size", "hh"]
        ].rename(columns={"household_size": "metric", "hh": "value"}).assign(
            metric=lambda df: "Household Size - "
            + df["metric"].astype(str).replace(7, "7+")
        ).to_sql(
            schema="outputs",
            name="hh_characteristics",
            if_exists="append",
            con=conn,
            index=False,
        )
